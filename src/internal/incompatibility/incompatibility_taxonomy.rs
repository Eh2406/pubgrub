//! This is part internal documentation, part literate programming, part tests of incompatibilities.
//! As such it is intended to be read from top to bottom. There will be code to make sure the statements
//! are correct but that is incidental to the core narrative.
//! This module will enumerate all the configuration of incompatibilities and
//! try and describe/test the uses and properties of each configuration.

use crate::range::Range;

use super::*;
type TestIncompat<'a> = Incompatibility<u8, Range<u8>, &'a str>;

/// Fundamentally an incompatibility is a `Set` of `Terms`.
/// So the first case to consider is the empty set.
#[test]
fn terminal() {
    let inc: TestIncompat = Incompatibility {
        package_terms: SmallMap::Empty,
        kind: Kind::DerivedFrom(Id::synthesize_test_value(1), Id::synthesize_test_value(2)),
    };
    // The arguments don't matter this is always terminal.
    assert!(inc.is_terminal(&0, &0));
    // That is equivalent to saying that it is always satisfied.
    assert_eq!(
        Relation::Satisfied,
        inc.relation(|_| {
            unreachable!("It should be satisfied without looking at what decisions were made");
        })
    );
}

/// Moving up to the case of a single `Terms` requires us to more carefully investigate the shape of `Terms`.
/// A term can either be `Positive` or `Negative`. A single `Negative` `Term` has a productive use it is what starts
/// resolution.
#[test]
fn not_root() {
    let inc: TestIncompat = Incompatibility::not_root(1, 42);

    // It starts off `AlmostSatisfied` before any decision is made.
    assert_eq!(Relation::AlmostSatisfied(1), inc.relation(|_| None));

    // Which is equivalent to a partial decision that's inconclusive.
    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::AlmostSatisfied(1),
        inc.relation(|_| Some(&pos_inc))
    );

    // It is `Contradicted` once a compatible version is chosen.
    let pos_con = Term::Positive(Range::singleton(42));
    assert_eq!(Relation::Contradicted(1), inc.relation(|_| Some(&pos_con)));

    // It is `Satisfied` if an incompatible version is chosen.
    let pos_sat = Term::Positive(Range::singleton(66));
    assert_eq!(Relation::Satisfied, inc.relation(|_| Some(&pos_sat)));

    // Ther is no way for a single `Negative` `Term` to be `Inconclusive`.

    // This shape also has practical use aside from `not_root`,
    // as it can be generated by combining `not_root` with one of roots dependencies.
}

/// Next we should consider a single `Positive` `Term` which has the
/// productive use of marking some versions as unavailable.
#[test]
fn unavailable() {
    let inc: TestIncompat = Incompatibility::no_versions(1, Term::Positive(Range::singleton(42)));

    // It starts off `AlmostSatisfied` before any decision is made.
    assert_eq!(Relation::AlmostSatisfied(1), inc.relation(|_| None));

    // Which is equivalent to a partial decision that's inconclusive.
    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::AlmostSatisfied(1),
        inc.relation(|_| Some(&pos_inc))
    );

    // It is `Satisfied` once a compatible version is chosen.
    let pos_sat = Term::Positive(Range::singleton(42));
    assert_eq!(Relation::Satisfied, inc.relation(|_| Some(&pos_sat)));

    // It is `Contradicted` if an incompatible version is chosen.
    let pos_con = Term::Positive(Range::singleton(66));
    assert_eq!(Relation::Contradicted(1), inc.relation(|_| Some(&pos_con)));
}

/// Next we should look at incompatibilities with two `Terms`.
/// Of which there are three possible patterns.
/// The most common type is with one being positive and the other one being negative.
/// This productively encodes a normal dependency edge.
#[test]
fn dependency() {
    let inc: TestIncompat =
        Incompatibility::from_dependency(1, Range::singleton(2), (3, Range::singleton(42)));

    // It starts off `Inconclusive` before any decision is made.
    assert_eq!(Relation::Inconclusive, inc.relation(|_| None));

    // Which is equivalent to a partial decision that's inconclusive about the positive term.
    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    // Or the negitive term
    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    // It is `Contradicted` once a incompatible version is chosen about the positive term.
    let pos_inc = Term::Positive(Range::singleton(10));
    assert_eq!(
        Relation::Contradicted(1),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    // Or a compatible version is chosen about the negitive term.
    let pos_inc = Term::Positive(Range::singleton(42));
    assert_eq!(
        Relation::Contradicted(3),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    // It is `AlmostSatisfied` once a compatible version is chosen about the positive term.
    let pos_inc = Term::Positive(Range::singleton(2));
    assert_eq!(
        Relation::AlmostSatisfied(3),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    // Or a incompatible version is chosen about the negitive term.
    let pos_inc = Term::Positive(Range::singleton(5));
    assert_eq!(
        Relation::AlmostSatisfied(1),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );
    // If A decision about either term is sufficient to make the hole thing contradicted
    // than a decision about the other term does not matter.
    // Similarly, if only one term is inconclusive then the whole thing is almost satisfied.
    // And if both are inconclusive than the whole thing is inconclusive.
    // These are properties of `relation` so I don't feel like belaboring them with tests at the moment.

    // The whole thing can become `Satisfied` once a compatible version is chosen
    // about the positive term and a incompatible version is chosen about the negitive term
    let pos_com_1 = Term::Positive(Range::singleton(2));
    let pos_inc_2 = Term::Positive(Range::singleton(5));
    assert_eq!(
        Relation::Satisfied,
        inc.relation(|p| { Some(if p == &1 { &pos_com_1 } else { &pos_inc_2 }) })
    );
}

#[test]
fn constrained() {
    let inc: TestIncompat = Incompatibility {
        package_terms: SmallMap::Two([
            (1, Term::Negative(Range::singleton(2))),
            (3, Term::Negative(Range::singleton(42))),
        ]),
        kind: Kind::DerivedFrom(Id::synthesize_test_value(1), Id::synthesize_test_value(2)),
    };

    assert_eq!(Relation::Inconclusive, inc.relation(|_| None));

    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(10));
    assert_eq!(
        Relation::AlmostSatisfied(3),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(42));
    assert_eq!(
        Relation::Contradicted(3),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(2));
    assert_eq!(
        Relation::Contradicted(1),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(5));
    assert_eq!(
        Relation::AlmostSatisfied(1),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_com_1 = Term::Positive(Range::singleton(20));
    let pos_inc_2 = Term::Positive(Range::singleton(4));
    assert_eq!(
        Relation::Satisfied,
        inc.relation(|p| { Some(if p == &1 { &pos_com_1 } else { &pos_inc_2 }) })
    );
}

#[test]
fn contradicted() {
    let inc: TestIncompat = Incompatibility {
        package_terms: SmallMap::Two([
            (1, Term::Positive(Range::singleton(2))),
            (3, Term::Positive(Range::singleton(42))),
        ]),
        kind: Kind::DerivedFrom(Id::synthesize_test_value(1), Id::synthesize_test_value(2)),
    };

    assert_eq!(Relation::Inconclusive, inc.relation(|_| None));

    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::full());
    assert_eq!(
        Relation::Inconclusive,
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(10));
    assert_eq!(
        Relation::Contradicted(1),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(42));
    assert_eq!(
        Relation::AlmostSatisfied(1),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(2));
    assert_eq!(
        Relation::AlmostSatisfied(3),
        inc.relation(|p| (p == &1).then_some(&pos_inc))
    );

    let pos_inc = Term::Positive(Range::singleton(5));
    assert_eq!(
        Relation::Contradicted(3),
        inc.relation(|p| (p == &3).then_some(&pos_inc))
    );

    let pos_com_1 = Term::Positive(Range::singleton(2));
    let pos_inc_2 = Term::Positive(Range::singleton(42));
    assert_eq!(
        Relation::Satisfied,
        inc.relation(|p| { Some(if p == &1 { &pos_com_1 } else { &pos_inc_2 }) })
    );
}
